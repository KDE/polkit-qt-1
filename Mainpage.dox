/**
\mainpage Polkit-qt - Qt PolicyKit wrapper

\section polkitqt_overview Overview

Polkit-qt aims to make it easy for Qt developers to take advantage of
PolicyKit API. It is a convenience wrapper around QAction and QAbstractButton
that lets you integrate those two components easily with PolicyKit.

Polkit-qt is splitted in two libraries: polkit-qt-core and polkit-qt-gui. 

polkit-qt-core lets you control actions and authentication without a GUI, with some very
simple functions. It also lets you retrieve and control useful informations on the PolicyKit
context. It includes the classes Auth and Context.

polkit-qt-gui lets you easily associate GUI items with PolicyKit actions. By some simple
wrapper classes you are able to associate QAction and QAbstractButton to a PolicyKit action,
and get their properties changed accordingly to PolicyKit result. It includes the classes
Action, ActionButton and ActionButtons

\li A sample usage of polkit-qt can be found in \ref polkitqt_example
\li <a href="classes.html">Alphabetical Class List</a>
\li <a href="hierarchy.html">Class Hierarchy</a>




\page polkitqt_example Polkit-qt usage example

You can find an example usage of Polkit-qt in the examples/ dir. You can
build it by passing \c -DBUILD_EXAMPLES=TRUE to your cmake line. The structure
consists of a .ui file and a main class, to demonstrate how easy it is to integrate
PolicyKit support in an existing application. Let's see some details about it:

\code
bt = new ActionButton(kickPB, "org.qt.policykit.examples.kick", this);
bt->setText("Kick... (long)");
// here we set the behavior of PolKitResul = No
bt->setNoVisible(true);
bt->setNoEnabled(true);
bt->setNoText("Kick (long)");
bt->setNoIcon(QPixmap(":/Icons/custom-no.png"));
bt->setNoToolTip("If your admin wasn't annoying, you could do this");
// here we set the behavior of PolKitResul = Auth
bt->setAuthVisible(true);
bt->setAuthEnabled(true);
bt->setAuthText("Kick... (long)");
bt->setAuthIcon(QPixmap(":/Icons/action-locked-default.png"));
bt->setAuthToolTip("Only card carrying tweakers can do this!");
// here we set the behavior of PolKitResul = Yes
bt->setYesVisible(true);
bt->setYesEnabled(true);
bt->setYesText("Kick! (long)");
bt->setYesIcon(QPixmap(":/Icons/custom-yes.png"));
bt->setYesToolTip("Go ahead, kick kick kick!");
\endcode

This small paragraph sets up an action button using an existing button defined in the
UI file, \c kickPB . As you can see, you can set custom properties on your button depending
on the action status/result. The code is mostly self-explainatory

\code
bt = new ActionButtons(QList<QAbstractButton*>() << listenPB << listenCB,
                           "org.qt.policykit.examples.listen", this);
bt->setIcon(QPixmap(":/Icons/action-locked.png"));
bt->setYesIcon(QPixmap(":/Icons/action-unlocked.png"));
bt->setText("Click to make changes...");
\endcode

This demonstrates the use of ActionButtons, that lets you associate multiple buttons with a
single action with extreme ease. \c listenPB and \c listenCB, both defined in the ui file,
are kept in sync with the action.

\code
connect(bt, SIGNAL(triggered(bool)), this, SLOT(activateAction()));
connect(bt, SIGNAL(clicked(QAbstractButton*,bool)), bt, SLOT(activate()));
connect(bt, SIGNAL(activated()), this, SLOT(actionActivated()));
\endcode

Those three signals are all you need to control the action and the activation. Action::triggered()
lets you start the activation/revoke when needed, ActionButton::clicked() lets you do the same thing
with even more ease, just by manually connecting the signal to ActionButton::activate() (see the docs
to understand why this connection doesn't happen automatically), and Action::activated() signal notifies
you when PolicyKit has authorized you to perform the action.

As you can see, usage of Polkit-Qt is extremely simple. Have a look at the complete example
and to the API Docs for more details.


*/

// DOXYGEN_PROJECTVERSION=0.9.2
// DOXYGEN_PROJECTNAME=PolKit-Qt
// DOXYGEN_ENABLE=YES

// vim:ts=4:sw=4:expandtab:filetype=doxygen
